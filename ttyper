<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ttyper</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: monospace, monospace;
            font-size: 16px;
            line-height: 1.4;
            overflow: hidden;
        }

        #terminal {
            box-sizing: border-box;
            width: 100vw;
            height: 100vh;
            padding: 10px 20px;
            white-space: pre-wrap;
            overflow-y: auto;
            outline: none;
            user-select: none;
        }

        ::-webkit-scrollbar {
            width: 8px;
            background: #111;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
        }
    </style>
</head>

<body>

    <div id="terminal" tabindex="0"></div>

    <script>
        // Extended and longer C code string simulating complex program
  const code = `#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>

#define N 256
#define M 128

typedef struct {
    double data[N][M];
    double transform[N][M];
    int flags[N];
    char label[N][32];
} DataBlock;

typedef struct {
    double state[N];
    int config[M];
} ControlBlock;

void randomize_label(char *label, int len) {
    static const char chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
    for (int i = 0; i < len - 1; i++) {
        label[i] = chars[rand() % (sizeof(chars) - 1)];
    }
    label[len - 1] = '\\0';
}

void initialize_data(DataBlock *db, ControlBlock *cb) {
    for (int i = 0; i < N; i++) {
        db->flags[i] = rand() % 2;
        randomize_label(db->label[i], sizeof(db->label[i]));
        cb->state[i] = (double)(rand() % 10000) / 10000.0;
        for (int j = 0; j < M; j++) {
            db->data[i][j] = sin(i * 0.05) * cos(j * 0.035) + ((double)rand() / RAND_MAX);
            db->transform[i][j] = 0.0;
            if (i == 0) {
                cb->config[j] = rand() % 10;
            }
        }
    }
}

void apply_transformations(DataBlock *db, ControlBlock *cb) {
    for (int cycle = 0; cycle < 800; cycle++) {
        for (int i = 0; i < N; i++) {
            double acc = 0.0;
            for (int j = 0; j < M; j++) {
                double val = db->data[i][j];
                val = pow(fabs(val), 1.3) * sin(val * 3.1415926535);
                val *= 1.0 + 0.1 * sin(cb->state[i] + j * 0.025);
                if (cb->config[j] & 1) {
                    val += cos(cb->state[i] * j);
                } else {
                    val -= sin(cb->state[i] / (j + 1));
                }
                db->transform[i][j] = val;
                acc += val;
            }
            cb->state[i] = fmod(acc / M + cb->state[i], 1.0);
        }

        for (int i = 0; i < N; i++) {
            if (db->flags[i]) {
                for (int j = 0; j < M - 1; j++) {
                    db->data[i][j] = (db->transform[i][j] + db->transform[i][j + 1]) / 2.0;
                }
                db->data[i][M - 1] = db->transform[i][M - 1];
            } else {
                for (int j = 0; j < M; j++) {
                    db->data[i][j] = db->transform[(i + 1) % N][j] * 0.75 + db->transform[(i + N - 1) % N][j] * 0.25;
                }
            }
        }
    }
}

double complex_computation(DataBlock *db, ControlBlock *cb) {
    double result = 0.0;
    for (int i = 0; i < N; i++) {
        double local_sum = 0.0;
        for (int j = 0; j < M; j++) {
            double val = db->data[i][j];
            int sign = (cb->config[j] % 5) - 2;
            val *= sign ? sign * pow(sin(val + i + j), 2) : 1.0;
            val += log(fabs(cb->state[i] * (j + 1)) + 1.0);
            local_sum += val;
        }
        if (db->flags[i]) {
            result += sqrt(fabs(local_sum)) * sin(local_sum / (i + 1));
        } else {
            result -= cbrt(fabs(local_sum)) * cos(local_sum / (i + 1));
        }
    }
    return result;
}

void print_summary(DataBlock *db, ControlBlock *cb) {
    int set_bits = 0;
    int label_ascii_sum = 0;
    for (int i = 0; i < N; i++) {
        if (db->flags[i]) set_bits++;
        for (int k = 0; db->label[i][k]; k++) {
            label_ascii_sum += db->label[i][k];
        }
    }
    
    printf("Flags set: %d out of %d\\n", set_bits, N);
    printf("Label ASCII sum: %d\\n", label_ascii_sum);
    printf("Control config stats: ");
    for (int j = 0; j < M; j++) {
        printf("%d ", cb->config[j]);
    }
    printf("\\n");
}

int main() {
    srand((unsigned)time(NULL));

    DataBlock db;
    ControlBlock cb;

    initialize_data(&db, &cb);
    apply_transformations(&db, &cb);

    double final_result = complex_computation(&db, &cb);

    print_summary(&db, &cb);
    printf("Final computed value: %.18lf\\n", final_result);

    return 0;
}
`;

  const term = document.getElementById('terminal');
  let index = 0;
  let typing = false;

  term.focus();

  function typeChar() {
    if (index < code.length) {
      term.textContent += code[index];
      index++;
      term.scrollTop = term.scrollHeight;
    } else {
      typing = false;
    }
  }

  function typeTwoCharsWithDelay() {
    if (typing) return; // prevent overlapping calls
    typing = true;
    typeChar();
    setTimeout(() => {
      typeChar();
      typing = false;
    }, 80); // 80ms delay between the two chars
  }

  window.addEventListener('keydown', (e) => {
    if (index < code.length) {
      typeTwoCharsWithDelay();
    }
  });
    </script>

</body>

</html>
